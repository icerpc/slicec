// Copyright (c) ZeroC, Inc. All rights reserved.

mod builders;
mod class_visitor;
mod code_block;
mod comments;
mod cs_options;
mod cs_util;
mod cs_validator;
mod decoding;
mod dispatch_visitor;
mod encoded_result;
mod encoding;
mod enum_visitor;
mod exception_visitor;
mod generated_code;
mod member_util;
mod module_visitor;
mod proxy_visitor;
mod slicec_ext;
mod struct_visitor;

use class_visitor::ClassVisitor;
use cs_options::CsOptions;
use cs_validator::CsValidator;
use dispatch_visitor::DispatchVisitor;
use enum_visitor::EnumVisitor;
use exception_visitor::ExceptionVisitor;
use generated_code::GeneratedCode;
use module_visitor::ModuleVisitor;
use proxy_visitor::ProxyVisitor;
use slice::slice_file::SliceFile;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use struct_visitor::StructVisitor;
use structopt::StructOpt;

use crate::code_block::CodeBlock;

pub fn main() {
    std::process::exit(match try_main() {
        Ok(()) => 0,
        Err(()) => 1,
    })
}

fn try_main() -> Result<(), ()> {
    let options = CsOptions::from_args();
    let slice_options = &options.slice_options;
    let mut data = slice::parse_from_options(slice_options)?;

    let mut cs_validator = CsValidator::new(&mut data.error_handler);
    for slice_file in data.slice_files.values() {
        slice_file.visit_with(&mut cs_validator, &data.ast);
    }
    slice::handle_errors(
        slice_options.warn_as_error,
        &mut data.error_handler,
        &data.slice_files,
    )?;

    if !slice_options.validate {
        for slice_file in data.slice_files.values().filter(|file| file.is_source) {
            // TODO: actually check for the error

            let mut generated_code = GeneratedCode::new();

            generated_code.code_blocks.push(preamble(slice_file));

            let mut visitor = StructVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut visitor, &data.ast);

            let mut proxy_visitor = ProxyVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut proxy_visitor, &data.ast);

            let mut dispatch_visitor = DispatchVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut dispatch_visitor, &data.ast);

            let mut exception_visitor = ExceptionVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut exception_visitor, &data.ast);

            let mut enum_visitor = EnumVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut enum_visitor, &data.ast);

            let mut class_visitor = ClassVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut class_visitor, &data.ast);

            let mut module_visitor = ModuleVisitor { generated_code: &mut generated_code };
            slice_file.visit_with(&mut module_visitor, &data.ast);

            {
                let path = match &slice_options.output_dir {
                    Some(output_dir) => Path::new(output_dir),
                    _ => Path::new("."),
                }
                .join(format!("{}.cs", &slice_file.filename))
                .to_owned();

                let mut file = match File::create(&path) {
                    Ok(file) => file,
                    Err(err) => {
                        data.error_handler.report_error(
                            format!("failed to create file {}: {}", &path.display(), err).into(),
                        );
                        continue;
                    }
                };

                match file.write_all(
                    generated_code
                        .code_blocks
                        .into_iter()
                        .collect::<CodeBlock>()
                        .into_string()
                        .as_bytes(),
                ) {
                    Ok(_) => (),
                    Err(err) => {
                        data.error_handler.report_error(
                            format!("failed to write to file {}: {}", &path.display(), err).into(),
                        );
                        continue;
                    }
                }
            }
        }
    }

    slice::handle_errors(true, &mut data.error_handler, &data.slice_files)
}

fn preamble(slice_file: &SliceFile) -> CodeBlock {
    format!(
        r#"// Copyright (c) ZeroC, Inc. All rights reserved.

// <auto-generated/>
// slicec-cs version: '{version}'
// Generated from file: '{file}.ice'

#nullable enable

#pragma warning disable 1591 // Missing XML Comment
using IceRpc.Slice;

[assembly:IceRpc.Slice.Slice("{file}.ice")]"#,
        version = env!("CARGO_PKG_VERSION"),
        file = slice_file.filename
    )
    .into()
}
