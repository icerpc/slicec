// Copyright (c) ZeroC, Inc. All rights reserved.
// TODO rewrite this with better error handling in mind.
// This was just copy & pasted from the original implementation and can be improved alot.

main = { SOI ~ file_attributes ~ module_def* ~ EOI }

definition = { module_def | struct_def | class_def | exception_def | interface_def | enum_def | trait_def | type_alias }

module_start = ${ module_kw ~ ws+ ~ scoped_identifier }
module_def = !{ prelude ~ module_start ~ "{" ~ definition* ~ "}" }

struct_start = ${ compact_modifier ~ struct_kw ~ ws+ ~ identifier }
struct_def = !{ prelude ~ struct_start ~ "{" ~ data_member_list ~ "}" }

class_start = ${ class_kw ~ ws+ ~ identifier ~ compact_id ~ ( ws* ~ extends_kw ~ ws* ~ inheritance_list)? }
class_def = !{ prelude ~ class_start ~ "{" ~ data_member_list ~ "}" }

exception_start = ${ exception_kw ~ ws+ ~ identifier ~ ( ws* ~ extends_kw ~ ws* ~ inheritance_list)? }
exception_def = !{ prelude ~ exception_start ~ "{" ~ data_member_list ~ "}" }

interface_start = ${ interface_kw ~ ws+ ~ identifier ~ ( ws* ~ extends_kw ~ ws* ~ inheritance_list)? }
interface_def = !{ prelude ~ interface_start ~ "{" ~ operation* ~ "}" }

enum_start = ${ unchecked_modifier ~ enum_kw ~ ws+ ~ identifier ~ ( ws* ~ extends_kw ~ ws* ~ typeref )? }
enum_def = !{ prelude ~ enum_start ~ "{" ~ enumerator_list? ~ "}" }

trait_def = ${ prelude ~ ws* ~ trait_kw ~ ws+ ~ identifier ~ ws* ~ ";" }

return_type = ${ local_attributes ~ ws* ~ tag_modifier ~ stream_modifier ~ typeref | return_tuple }
return_tuple = !{ "(" ~ parameter_list ~ ")" }

operation_start = ${ idempotent_modifier ~ identifier}
operation_return = !{ ( "->" ~ return_type )? }
operation = !{ prelude ~ operation_start ~ "(" ~ parameter_list ~ ")" ~ operation_return ~ ";" }

data_member_list = !{ ( (data_member ~ "," ~ data_member_list) | data_member )? }
data_member = !{ prelude ~ identifier ~ ":" ~ tag_modifier ~ typeref }
parameter_list = !{ ( (parameter ~ "," ~ parameter_list) | parameter )? }
parameter = !{ prelude ~ identifier ~ ":" ~ tag_modifier ~ stream_modifier ~ typeref }

tag = !{ tag_kw ~ "(" ~ integer ~ ")" }
tag_modifier = { (tag ~ ws*)? }

enumerator_list = !{ ( enumerator ~ "," ~ enumerator_list ) | ( enumerator ~ ","? ) }
enumerator = !{ prelude ~ identifier ~ ( "=" ~ integer )? }

inheritance_list = !{ ( typeref ~ "," ~ inheritance_list ) | ( typeref ~ ","? ) }

type_alias = ${ prelude ~ ws* ~ type_alias_kw ~ ws+ ~ identifier ~ ws* ~ "=" ~ ws* ~ typeref ~ ws* ~ ";" }

typeref = ${ local_attributes ~ ws* ~ (primitive | sequence | dictionary | global_identifier | scoped_identifier) ~ (ws* ~ "?")? }

sequence = !{ sequence_kw ~ "<" ~ typeref ~ ">" }
dictionary = !{ dictionary_kw ~ "<" ~ typeref ~ "," ~ typeref ~ ">" }

primitive = {
    bool_kw     |
    byte_kw     |
    short_kw    |
    ushort_kw   |
    int_kw      |
    uint_kw     |
    varint_kw   |
    varuint_kw  |
    long_kw     |
    ulong_kw    |
    varlong_kw  |
    varulong_kw |
    float_kw    |
    double_kw   |
    string_kw   |
    any_class_kw
}

identifier = @{ "\\"? ~ ASCII_ALPHA ~ ( "_" | ASCII_ALPHANUMERIC )* }
global_identifier = @{ ( "::" ~ identifier )+ }
scoped_identifier = @{ identifier ~ ( "::" ~ identifier )* }

prelude = !{ local_attributes ~ doc_comment ~ local_attributes }

file_attributes = !{ ("[[" ~ attribute ~ "]]")* }
local_attributes = !{ ("[" ~ attribute ~ "]")* }
attribute = !{ attribute_directive ~ ( "(" ~ attribute_arguments? ~ ")" )? }
attribute_directive = ${ attribute_identifier ~ (":" ~ attribute_identifier)? }
attribute_identifier = @{ (ASCII_ALPHANUMERIC | "_" | "-")+ }
attribute_argument = @{
    "\"" ~ (!"\"" ~ ANY)* ~ "\"" |          // Add support for escaped characters in the future.
    (ASCII_ALPHANUMERIC | "_" | "-" | ":" | "<" | ">")+
}
attribute_arguments = !{ ( attribute_argument ~ "," ~ attribute_arguments) | ( attribute_argument ~ ","? ) }

// "WHITESPACE" and "COMMENT" are special rules that Pest will implicitely allow to appear in between any other rules.
WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ line_comment | block_comment }
// "ws" is used for rules where we have to explicitely handle whitespace.
ws = _{ WHITESPACE | COMMENT }
doc_comment = { ( line_doc_comment+ | block_doc_comment )? }

line_comment = @{ !"///" ~ "//" ~ ( !NEWLINE ~ ANY )* }
line_doc_comment = @{ "///" ~ ( !NEWLINE ~ ANY )* }
block_comment = @{ !"/**" ~ "/*" ~ ( !"*/" ~ ANY )* ~ "*/" }
block_doc_comment = @{ "/**" ~ ( !"*/" ~ ANY )* ~ "*/" }

integer = @{ "-"? ~ ASCII_DIGIT+ }

compact_id = { ("(" ~ integer ~ ")")? }
stream_modifier = ${ (stream_kw ~ ws+)? }
compact_modifier = { (compact_kw ~ ws+)? }
idempotent_modifier = { (idempotent_kw ~ ws+)? }
unchecked_modifier = { (unchecked_kw ~ ws+)? }

module_kw = { "module" }
struct_kw = { "struct" }
class_kw = { "class" }
exception_kw = { "exception" }
interface_kw = { "interface" }
enum_kw = { "enum" }
trait_kw = { "trait" }
type_alias_kw = { "typealias" }

sequence_kw = { "sequence" }
dictionary_kw = { "dictionary" }

bool_kw = { "bool" ~ !ASCII_ALPHA }
byte_kw = { "byte" ~ !ASCII_ALPHA }
short_kw = { "short" ~ !ASCII_ALPHA }
ushort_kw = { "ushort" ~ !ASCII_ALPHA }
int_kw = { "int" ~ !ASCII_ALPHA }
uint_kw = { "uint" ~ !ASCII_ALPHA }
varint_kw = { "varint" ~ !ASCII_ALPHA }
varuint_kw = { "varuint" ~ !ASCII_ALPHA }
long_kw = { "long" ~ !ASCII_ALPHA }
ulong_kw = { "ulong" ~ !ASCII_ALPHA }
varlong_kw = { "varlong" ~ !ASCII_ALPHA }
varulong_kw = { "varulong" ~ !ASCII_ALPHA }
float_kw = { "float" ~ !ASCII_ALPHA }
double_kw = { "double" ~ !ASCII_ALPHA }
string_kw = { "string" ~ !ASCII_ALPHA }
any_class_kw = { "AnyClass" ~ !ASCII_ALPHA }

tag_kw = { "tag" ~ !ASCII_ALPHA }
stream_kw = { "stream" ~ !ASCII_ALPHA }
extends_kw = { ":" }
compact_kw = { "compact" ~ !ASCII_ALPHA }
idempotent_kw = { "idempotent" ~ !ASCII_ALPHA }
unchecked_kw = { "unchecked" ~ !ASCII_ALPHA }
